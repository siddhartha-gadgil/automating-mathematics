<!doctype html>

<html lang="en">

<head>
  <title>Artificial Intelligence and Mathematics</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="Siddhartha Gadgil" />
  <meta name="generator" content="Hugo 0.46" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://siddhartha-gadgil.github.io/automating-mathematics/css/styles.css" />
  <link rel="icon" href="https://siddhartha-gadgil.github.io/automating-mathematics/IIScLogo.jpg"></head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://siddhartha-gadgil.github.io/automating-mathematics/">Artificial Intelligence and Mathematics</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/SidGadgil"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
          
        <li><a href="https://github.com/siddhartha-gadgil"><i class="fa fa-github fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://gitlab.com/siddhartha.gadgil"><i class="fa fa-gitlab fa-lg" aria-hidden="true"></i></a></li>
          
      </ul>
      
      <p><em>towards Automating Mathematics</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Levels of Thought</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2018-08-06T15:55:56&#43;05:30">Aug 6, 2018</time>
        </li>
        
        

        

        <li>8 min read</li>
    </ul>
</aside>
    

    

<p>Computers excel at routine tasks and are capable of performing these with great precision and speed. Indeed one can even argue that the more routine a task is, the more the <em>comparative</em> advantage of a computer in performing this task, and so people have a <em>comparative</em> advantage in more sophisticated tasks. Yet it would be a fallacy to conclude from this that people are better at high-level tasks than computers.</p>

<p>It is true that as computers can perform many more steps accurately and rapidly, the easiest way to get a computer to solve a problem is often using a lower level of thinking than for a person to solve the same problem, i.e., trade <em>brute force</em> for sophistication.</p>

<p>However, the major waves in automation have come from computers being able to handle tasks at successively higher cognitive levels. This is masked to some extent by the ability of computers to substitute a higher level of cognition with raw power at a lower level - but this has its limitations. Indeed we shall illustrate that in the present era (starting with about 2008), computers have exhibited all forms of high-level cognition.</p>

<h1 id="levels-by-how">Levels by &ldquo;how?&rdquo;</h1>

<h3 id="arithmetic-and-logic">Arithmetic and Logic</h3>

<p>A pocket calculator can perform basic arithmetic operations. Arithmetic operations require also</p>

<ul>
<li><strong>logic</strong> - while subtracting <code>m</code> from <code>n</code>, <em>if</em> a digit of <code>m</code> is larger than the corresponding one for <code>n</code> we subtract.</li>
<li><strong>loops</strong> - once we know the basic method, we can apply it <em>for</em> each digit of a number to add/subtract arbitrarily long numbers. Further, while multiplying arbitrary numbers <code>m</code> and <code>n</code>, we have one term for each digit of <code>n</code>, with each term involving multiplying that digit with each digit of <code>m</code>. In doing these, we have used <em>nested loops</em>.</li>
</ul>

<p>It does not need any more sophistication to handle instead lists of numbers, lists of lists of numbers (matrices), list of letters (words) etc. Indeed all computation can in principle be reduced to this level. Doing this would be the most extreme version of brute force.</p>

<h3 id="breaking-tasks-into-simpler-ones-procedures-and-functions">Breaking tasks into simpler ones: procedures and functions</h3>

<p>A core of thinking is to break up a task into its constituents. For instance, in solving a quadratic equation we perform several arithmetic operations. But we do not think of the description of the solution as <em>including</em> descriptions of adding and multiplying numbers. Instead we <em>refer</em> to descriptions of these more basic operations, which we have learnt elsewhere. When using the function, we pass <em>arguments</em> - such as numbers to subtract.</p>

<p><em>Functions</em> (and <em>procedures</em>) in programming languages play this role. Indeed many general purpose programming languages, such as <em>Fortran</em> and <em>Cobol</em> do not go far beyond this level. This significantly limits their capabilities - for instance, there is no compiler for Fortran written in Fortran.</p>

<h4 id="why-this-is-a-higher-level">Why this is a higher level</h4>

<p>It is worth considering, as a contrast, a so called <em>macro</em> or <em>templating</em> language. Such languages are often used in special situations, for instances to add some smart shortcuts for word processing software or spreadsheets, or in templates for a web site.</p>

<p>In a macro language, we can describe the basic arithmetic operations and then describe the solution of a quadratic equation in terms of these, using logic and loops). However, when processing this, the interpreter copy-pastes the description of, say, addition, whenever an addition is used in solving a quadratic equation. This means the program can be resolved to one at the lower level. Evidently this works, but is much less efficient and becomes increasingly harder (and less pleasant) to use as we try to encode more sophisticated tasks.</p>

<p>All level jumps involve this - we can do stuff at the lower level in principle, but at a cost that makes it impractical and unpleasant.</p>

<h3 id="recursion-higher-order-functions">Recursion, Higher order functions</h3>

<p>Functions can be defined in terms of other (simpler) functions. <em>Recursive</em> definitions define functions in terms of themselves, with <em>arguments</em> being simpler, such as the factorial function <code>(n+1)! = (n+1)n!</code>. At a more sophisticated level, the arguments of a function can be a function itself.</p>

<h3 id="building-objects-from-constituents">Building objects from constituents</h3>

<p>Just as we can define functions by <em>decomposing</em> into simpler functions, or functions called with <em>simpler</em> arguments, we can build objects (or structures) from constituents. Indeed this capability is at the heart of natural languages - we can build arbitrarily complex sentences using rules such as combining an <em>adjectival phrase</em> and a <em>noun phrase</em> gives a <em>noun phrase</em>. Notice that this is rule is <em>recursive</em>.</p>

<p>Functions and structures built recursively give all the complexity needed in practice in the sense of architecture of thought, or of hardware and software. The advances in Aritificial intelligence have come not (mainly) from more complex software, but doing things differently.</p>

<h1 id="levels-by-what">Levels by &ldquo;what?&rdquo;</h1>

<p>Advances of machine learning, while involving many great ideas, are not due to doing things in a more sophisticated way, but rather by doing things differently. Indeed many of the key ideas date back to the 1980s, and some even to the 1950s. However for these to be effective needed powerful hardware. Ironically, sophisticated solutions needs more brute force than brute force solutions.</p>

<h3 id="hard-to-solve-easy-to-check">Hard to solve, easy to check</h3>

<p>We tend to call answers <em>clever</em>, or even <em>creative</em>, if we can see that they are correct but cannot see how they were found. Indeed puzzles (such as Sudoku) are typically of this nature.</p>

<p>Indeed we have an analagous situation even with subjective judgements - while it takes a certain sense of language and rhythm to enjoy a poem such as Poe&rsquo;s Raven, writing such a poem requires an entirely different level of thinking.</p>

<p>Computers have long been capable of solving many such problems very well. It is higher levels at which they failed.</p>

<h3 id="tacit-knowledge">Tacit knowledge</h3>

<p>As <a href="https://en.wikipedia.org/wiki/Tacit_knowledge">wikipedia</a> defines it:
tacit knowledge (as opposed to formal, codified or explicit knowledge) is the kind of knowledge that is difficult to transfer to another person by means of writing
it down or verbalizing it.</p>

<p>This is encapsulated in the assertion &ldquo;we can know more than we can tell&rdquo; of Michael Polanyi. A typical example of such tacit knowledge is the ability to ride a bicycle. A top chess player has tacit knowledge of the strength of white in a game that is far better than the explicit rules that can be written down.</p>

<p>A fundamental weakness of computers till a decade ago was that they depended on being programmed to carry out explicitly understood solutions. This made them hopeless at many cognitive tasks. Systems based on <em>machine learning</em> instead learn how to handle tasks with experience, which is also our source of tacit knowledge. The task of programming becomes one of explicitly specifying how to learn, not unlike teaching someone to bicycle.</p>

<h3 id="intuitive-ideas">Intuitive ideas</h3>

<p>We often make choices whose correctness depends on either things in the future or unknown. We can try to make these choices <em>logically</em>, where we explicitly consider as many possibilities for the future as is reasonable, and have a policy for dealing with what remains unknown. For example, we can consider a certain number of moves in chess, and consider the best outcome based on the results at the end of these moves. Traditional chess playing programs do this (and are also limited by using the inferior explicit function to judge the position at the end of these).</p>

<p>We often instead make choices that are not logical. Often these are in fact <em>illogical</em>, i.e., simply bad choices. But in many cases we do have strong <em>intuition</em>, so we make choices that turn out in the fullness of time to often be the correct ones.</p>

<p>In this sense, systems based on <em>deep learning</em> do show <em>intuition</em>. The choices are based on a function that is some complicated that we cannot describe it in understandable terms. Further, if we simplify it to be easily describable, it does not work well.</p>

<h3 id="judgement-and-taste">Judgement and Taste</h3>

<p>Besides immediate applications, the value of a mathematical, or scientific, discovery lies in it leading to more (good) mathematics, and possibly future applications. A subtle skill, but essential at a high level, is to have the judgement or taste to recognise value before the consequences are evident. This is even more subtle than making choices based on intuition.</p>

<p>The systems <em>AlphaGo</em> and <em>AlphaZero</em> have shown refined judgement in evaluating positions in board games, with evaluation better than human champions.</p>

<h3 id="organized-knowledge">Organized knowledge</h3>

<p>Our knowledge is organized based on meaning and use. For instance we perceive two words as similar based on their meanings more than their sounds. Further, a visual scene is perceived as composing of distinct objects, not as an array of pixels.</p>

<p>Using <em>representation learning</em>, computers can organize knowledge by meaning too. For instance, the <code>Word2Vec</code> system maps words to vectors in a high-dimensional space, by training using an artificial problem. We can see that this captures many properties of words, not just similarity but analogies.</p>

<h3 id="analogical-reasoning">Analogical reasoning</h3>

<p>Much of our reasoning is based on analogy, which comes more naturally to us than formal abstraction. Indeed ancient Babylonian and Indian mathematics was explained purely through analogy.</p>

<p>As we mentioned, systems based on representation learning capture analogy automatically. It seems likely that extensions of these that seek analogies will do even better.</p>

<h3 id="efficient-learning">Efficient learning</h3>

<p>In the first wave of machine learning, systems performed very well but needed a large amount of labelled data. This limited the tasks that could be learnt, and made training expensive. To overcome this, the idea of <em>reinforcement learning</em> was introduced, where a system refined its learning through a large amount of simulation - not unlike a child learning through play.</p>

<p>A striking example of this is the best <em>Go</em> player today, <em>AplhaGo Zero</em> (the chinese game of <em>Go</em> is the hardest board game for computers). This is a system that learnt entirely by playing against itself, starting with just the rules of the game, i.e., with zero data.</p>


</article>


<section class="post-nav">
    <ul>
        
        
        <li>
            <a href="https://siddhartha-gadgil.github.io/automating-mathematics/posts/computer-assisted-proofs/">Computer Assisted Proofs <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
        <h6>Copyright &copy; 2018 - Siddhartha Gadgil | 
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://siddhartha-gadgil.github.io/automating-mathematics/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://siddhartha-gadgil.github.io/automating-mathematics/js/scripts.js"></script>
</body>

</html>